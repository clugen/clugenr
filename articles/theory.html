<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="clugenr">
<title>Theory • clugenr</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Theory">
<meta property="og:description" content="clugenr">
<meta property="og:image" content="/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">clugenr</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item">
  <a class="nav-link" href="../articles/theory.html">Theory</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-examples">Examples</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-examples">
    <a class="dropdown-item" href="../articles/examples2d.html">Examples in 2D</a>
    <a class="dropdown-item" href="../articles/examples3d.html">Examples in 3D</a>
    <a class="dropdown-item" href="../articles/examplesnd.html">Examples in other dimensions</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../articles/dev.html">Dev</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/clugen/clugenr/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Theory</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/clugen/clugenr/blob/HEAD/vignettes/theory.Rmd" class="external-link"><code>vignettes/theory.Rmd</code></a></small>
      <div class="d-none name"><code>theory.Rmd</code></div>
    </div>

    
    
<p>This vignette describes the theoretical framework of the
<em>clugen</em> algorithm, starting with a general <a href="#overview">Overview</a>, then moving on to a <a href="#detailed-description">Detailed description</a>.</p>
<div class="section level2">
<h2 id="overview">Overview<a class="anchor" aria-label="anchor" href="#overview"></a>
</h2>
<p><em>Clugen</em> is an algorithm for generating multidimensional
clusters. Each cluster is supported by a line segment, the position,
orientation and length of which guide where the respective points are
placed. For brevity, <em>line segments</em> will be referred to as
<em>lines</em>.</p>
<p>Given an <span class="math inline">\(n\)</span>-dimensional direction
vector <span class="math inline">\(\mathbf{d}\)</span> (and a number of
additional parameters, which will be discussed shortly), the
<em>clugen</em> algorithm works as follows (<span class="math inline">\(^*\)</span> means the algorithm step is
stochastic):</p>
<ol style="list-style-type: decimal">
<li>Normalize <span class="math inline">\(\mathbf{d}\)</span>.</li>
<li>
<span class="math inline">\(^*\)</span>Determine cluster sizes.</li>
<li>
<span class="math inline">\(^*\)</span>Determine cluster
centers.</li>
<li>
<span class="math inline">\(^*\)</span>Determine lengths of
cluster-supporting lines.</li>
<li>
<span class="math inline">\(^*\)</span>Determine angles between
<span class="math inline">\(\mathbf{d}\)</span> and cluster-supporting
lines.</li>
<li>For each cluster:
<ol style="list-style-type: decimal">
<li>
<span class="math inline">\(^*\)</span>Determine direction of the
cluster-supporting line.</li>
<li>
<span class="math inline">\(^*\)</span>Determine distance of point
projections from the center of the cluster-supporting line.</li>
<li>Determine coordinates of point projections on the cluster-supporting
line.</li>
<li>
<span class="math inline">\(^*\)</span>Determine points from their
projections on the cluster-supporting line.</li>
</ol>
</li>
</ol>
<p>Figure 1 provides a stylized overview of the algorithm’s steps.</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/clugen/.github/main/images/algorithm.png" alt=""><p class="caption"><strong>Figure 1</strong> - Stylized overview of the
<em>clugen</em> algorithm. Background tiles are 10 units wide and tall,
when applicable.</p>
</div>
<p>The example in Figure 1 was generated with the following parameters,
the exact meaning of each will be discussed shortly:</p>
<table class="table">
<colgroup>
<col width="41%">
<col width="58%">
</colgroup>
<thead><tr class="header">
<th align="left">Parameter values</th>
<th align="left">Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(n=2\)</span></td>
<td align="left">Number of dimensions.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(c=4\)</span></td>
<td align="left">Number of clusters.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(p=200\)</span></td>
<td align="left">Total number of points.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mathbf{d}=\begin{bmatrix}1
&amp; 1\end{bmatrix}^T\)</span></td>
<td align="left">Average direction.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\theta_\sigma=\pi/16\approx{}11.25^{\circ}\)</span></td>
<td align="left">Angle dispersion.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mathbf{s}=\begin{bmatrix}10 &amp;
10\end{bmatrix}^T\)</span></td>
<td align="left">Average cluster separation.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(l=10\)</span></td>
<td align="left">Average line length.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(l_\sigma=1.5\)</span></td>
<td align="left">Line length dispersion.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(f_\sigma=1\)</span></td>
<td align="left">Cluster lateral dispersion.</td>
</tr>
</tbody>
</table>
<p>Additionally, all optional parameters (not listed above) were left to
their default values. These will also be discussed next.</p>
</div>
<div class="section level2">
<h2 id="detailed-description">Detailed description<a class="anchor" aria-label="anchor" href="#detailed-description"></a>
</h2>
<p>In this section we provide a detailed description of the algorithm
and its parameters. We start by listing and describing all parameters
(mandatory and optional), and then analyze the algorithm in detail,
highlighting how each parameter influences the end result.</p>
<div class="section level3">
<h3 id="algorithm-parameters">Algorithm parameters<a class="anchor" aria-label="anchor" href="#algorithm-parameters"></a>
</h3>
<p>The <em>clugen</em> algorithm (and consequently, the
<code><a href="../reference/clugen.html">clugen()</a></code> function) has mandatory and optional parameters,
listed and described in the tables below. The optional parameters are
set to sensible defaults, and in many situations may be left unchanged.
Nonetheless, these allow all of the algorithm’s steps to be fully
customized by the user.</p>
<div class="section level4">
<h4 id="mandatory-parameters">Mandatory parameters<a class="anchor" aria-label="anchor" href="#mandatory-parameters"></a>
</h4>
<table class="table">
<colgroup>
<col width="17%">
<col width="18%">
<col width="65%">
</colgroup>
<thead><tr class="header">
<th align="left">Symbol</th>
<th align="left">Parameter</th>
<th align="left">Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(n\)</span></td>
<td align="left"><code>num_dims</code></td>
<td align="left">Number of dimensions.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(c\)</span></td>
<td align="left"><code>num_clusters</code></td>
<td align="left">Number of clusters.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(p\)</span></td>
<td align="left"><code>num_points</code></td>
<td align="left">Total number of points to generate.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mathbf{d}\)</span></td>
<td align="left"><code>direction</code></td>
<td align="left">Average direction of cluster-supporting lines (<span class="math inline">\(n \times 1\)</span>).</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\theta_\sigma\)</span></td>
<td align="left"><code>angle_disp</code></td>
<td align="left">Angle dispersion of cluster-supporting lines
(radians).</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mathbf{s}\)</span></td>
<td align="left"><code>cluster_sep</code></td>
<td align="left">Average cluster separation in each dimension (<span class="math inline">\(n \times 1\)</span>).</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(l\)</span></td>
<td align="left"><code>llength</code></td>
<td align="left">Average length of cluster-supporting lines.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(l_\sigma\)</span></td>
<td align="left"><code>llength_disp</code></td>
<td align="left">Length dispersion of cluster-supporting lines.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(f_\sigma\)</span></td>
<td align="left"><code>lateral_disp</code></td>
<td align="left">Cluster lateral dispersion, i.e., dispersion of points
from their projection on the cluster-supporting line.</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="optional-parameters">Optional parameters<a class="anchor" aria-label="anchor" href="#optional-parameters"></a>
</h4>
<table class="table">
<colgroup>
<col width="16%">
<col width="15%">
<col width="12%">
<col width="55%">
</colgroup>
<thead><tr class="header">
<th align="left">Symbol</th>
<th align="left">Parameter</th>
<th align="left">Default value</th>
<th align="left">Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(\phi\)</span></td>
<td align="left"><code>allow_empty</code></td>
<td align="left"><code>FALSE</code></td>
<td align="left">Allow empty clusters?</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mathbf{o}\)</span></td>
<td align="left"><code>cluster_offset</code></td>
<td align="left"><code>vector(mode = "integer", length = num_dims)</code></td>
<td align="left">Offset to add to all cluster centers (<span class="math inline">\(n \times 1\)</span>).</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(p_\text{proj}()\)</span></td>
<td align="left"><code>proj_dist_fn</code></td>
<td align="left"><code>"norm"</code></td>
<td align="left">Distribution of point projections along
cluster-supporting lines.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(p_\text{final}()\)</span></td>
<td align="left"><code>point_dist_fn</code></td>
<td align="left"><code>"n-1"</code></td>
<td align="left">Distribution of final points from their
projections.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(c_s()\)</span></td>
<td align="left"><code>clusizes_fn</code></td>
<td align="left"><code><a href="../reference/clusizes.html">clusizes()</a></code></td>
<td align="left">Distribution of cluster sizes.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(c_c()\)</span></td>
<td align="left"><code>clucenters_fn</code></td>
<td align="left"><code><a href="../reference/clucenters.html">clucenters()</a></code></td>
<td align="left">Distribution of cluster centers.</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(l()\)</span></td>
<td align="left"><code>llengths_fn</code></td>
<td align="left"><code><a href="../reference/llengths.html">llengths()</a></code></td>
<td align="left">Distribution of line lengths.</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\theta_\Delta()\)</span></td>
<td align="left"><code>angle_deltas_fn</code></td>
<td align="left"><code><a href="../reference/angle_deltas.html">angle_deltas()</a></code></td>
<td align="left">Distribution of line angle deltas (w.r.t. <span class="math inline">\(\mathbf{d}\)</span>).</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section level3">
<h3 id="the-algorithm-in-detail">The algorithm in detail<a class="anchor" aria-label="anchor" href="#the-algorithm-in-detail"></a>
</h3>
<p>The <em>clugen</em> algorithm is presented in <a href="#overview">Overview</a>. In this section we will analyze each of
the algorithms steps in detail.</p>
<div class="section level4">
<h4 id="normalize-mathbfd">1. Normalize <span class="math inline">\(\mathbf{d}\)</span><a class="anchor" aria-label="anchor" href="#normalize-mathbfd"></a>
</h4>
<p>This is a basic step, which consists of converting <span class="math inline">\(\mathbf{d}\)</span> to a unit vector:</p>
<p><span class="math display">\[
\hat{\mathbf{d}} = \cfrac{\mathbf{d}}{\left\lVert\mathbf{d}\right\rVert}
\]</span></p>
</div>
<div class="section level4">
<h4 id="determine-cluster-sizes">2. Determine cluster sizes<a class="anchor" aria-label="anchor" href="#determine-cluster-sizes"></a>
</h4>
<p>Cluster sizes are given by the <span class="math inline">\(c_s()\)</span> function according to:</p>
<p><span class="math display">\[
\mathbf{c_s} = c_s(c, p, \phi)
\]</span></p>
<p>where <span class="math inline">\(\mathbf{c_s}\)</span> is an <span class="math inline">\(c \times 1\)</span> integer vector containing the
final cluster sizes, <span class="math inline">\(c\)</span> is the
number of clusters, <span class="math inline">\(p\)</span> is the total
number of points, and <span class="math inline">\(\phi\)</span> is a
boolean which determines whether empty clusters are acceptable.</p>
<p>The <span class="math inline">\(c_s()\)</span> function is an
optional parameter, allowing users to customize its behavior. By
default, <span class="math inline">\(c_s()\)</span> is implemented by
the <code><a href="../reference/clusizes.html">clusizes()</a></code> function, which behaves according to the
following algorithm:</p>
<ol style="list-style-type: decimal">
<li>Determine the size <span class="math inline">\(p_i\)</span> of each
cluster <span class="math inline">\(i\)</span> according to <span class="math inline">\(p_i\sim\left\lfloor\max\left(\mathcal{N}(\frac{p}{c},
(\frac{p}{3c})^2),0\right)\right\rceil\)</span>, where <span class="math inline">\(\lfloor\rceil\)</span> denotes the round to
nearest integer function, and <span class="math inline">\(\mathcal{N}(\mu,\sigma^2)\)</span> represents the
normal distribution with mean <span class="math inline">\(\mu\)</span>
and variance <span class="math inline">\(\sigma^2\)</span>.</li>
<li>Assure that the final cluster sizes add up to <span class="math inline">\(p\)</span> by incrementing the smallest cluster
size while <span class="math inline">\(\sum_{i=1}^c p_i&lt;p\)</span> or
decrementing the largest cluster size while <span class="math inline">\(\sum_{i=1}^c p_i&gt;p\)</span>. This step is
delegated to the <code><a href="../reference/fix_num_points.html">fix_num_points()</a></code> helper function.</li>
<li>If <span class="math inline">\(\neg\phi\wedge p\ge c\)</span> then,
for each empty cluster <span class="math inline">\(i\)</span> (i.e.,
<span class="math inline">\(p_i=0\)</span>), increment <span class="math inline">\(p_i\)</span> and decrement <span class="math inline">\(p_j\)</span>, where <span class="math inline">\(j\)</span> denotes the largest cluster. This step
is delegated to the <code><a href="../reference/fix_empty.html">fix_empty()</a></code> helper function.</li>
</ol>
<p>Figure 2 demonstrates possible cluster sizes with various definitions
of <span class="math inline">\(c_s()\)</span> for <span class="math inline">\(c=4\)</span> and <span class="math inline">\(p=5000\)</span>. The default behavior, implemented
in the <code><a href="../reference/clusizes.html">clusizes()</a></code> function, is shown in Figure 2a, while
Figures 2b-d present results obtained with custom user functions. Figure
2b displays cluster sizes obtained with the discrete uniform
distribution over <span class="math inline">\(\left\{1, 2, \ldots,
\frac{2p}{c}\right\}\)</span>, corrected with
<code><a href="../reference/fix_num_points.html">fix_num_points()</a></code>. In turn, Figure 2c highlights cluster
sizes obtained with the Poisson distribution with <span class="math inline">\(\lambda=\frac{p}{c}\)</span>, also corrected with
<code><a href="../reference/fix_num_points.html">fix_num_points()</a></code>. The cluster sizes shown in Figure 2d were
determined with the same distribution (Poisson, <span class="math inline">\(\lambda=\frac{p}{c}\)</span>), but were not
corrected. Thus, cluster sizes do not add up to <span class="math inline">\(p\)</span>, highlighting the fact that this is not
a requirement of the <em>clugen</em> algorithm, i.e., user-defined <span class="math inline">\(c_s()\)</span> implementations can consider <span class="math inline">\(p\)</span> a hint rather than an obligation.</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/clugen/.github/main/images/clusizes.png" alt=""><p class="caption"><strong>Figure 2</strong> - Possible cluster sizes
with various definitions of <span class="math inline">\(c_s()\)</span>
for <span class="math inline">\(c=4\)</span> and <span class="math inline">\(p=5000\)</span>.</p>
</div>
</div>
<div class="section level4">
<h4 id="determine-cluster-centers">3. Determine cluster centers<a class="anchor" aria-label="anchor" href="#determine-cluster-centers"></a>
</h4>
<p>Cluster sizes are given by the <span class="math inline">\(c_c()\)</span> function according to:</p>
<p><span class="math display">\[
\mathbf{C} = c_c(c, \mathbf{s}, \mathbf{o})
\]</span></p>
<p>where <span class="math inline">\(\mathbf{C}\)</span> is an <span class="math inline">\(c \times n\)</span> matrix containing the final
cluster centers, <span class="math inline">\(c\)</span> is the number of
clusters, <span class="math inline">\(\mathbf{s}\)</span> is the average
cluster separation (<span class="math inline">\(n \times 1\)</span>
vector), and <span class="math inline">\(\mathbf{o}\)</span> is an <span class="math inline">\(n \times 1\)</span> vector of cluster offsets.</p>
<p>The <span class="math inline">\(c_c()\)</span> function is an
optional parameter, allowing users to customize its behavior. By
default, <span class="math inline">\(c_c()\)</span> is implemented by
the <code><a href="../reference/clucenters.html">clucenters()</a></code> function, which determines the cluster
centers according to:</p>
<p><span class="math display">\[
\mathbf{C}=c\mathbf{U} \cdot \operatorname{diag}(\mathbf{s}) +
\mathbf{1}\,\mathbf{o}^T
\]</span></p>
<p>where <span class="math inline">\(\mathbf{U}\)</span> is an <span class="math inline">\(c \times n\)</span> matrix of random values drawn
from the uniform distribution between -0.5 and 0.5, and <span class="math inline">\(\mathbf{1}\)</span> is an <span class="math inline">\(c \times 1\)</span> vector with all entries equal
to 1.</p>
<p>Figure 3 shows scatters plots of the results generated by
<em>clugen</em> for two different implementations of the <span class="math inline">\(c_c()\)</span> function, namely using the uniform
the distribution (the default, implemented by the
<code><a href="../reference/clucenters.html">clucenters()</a></code> function, Figure 3a), and direct specification
of cluster centers (Figure 3b).</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/clugen/.github/main/images/clucenters.png" alt=""><p class="caption"><strong>Figure 3</strong> - The output of
<em>clugen</em> for two different implementations of the <span class="math inline">\(c_c()\)</span> function for finding cluster
centers: a) the default, using the uniform distribution; b) hand-picked
centers. All parameters are the same as in Figure 1, except for <span class="math inline">\(p\)</span>, which is set to 5000.</p>
</div>
</div>
<div class="section level4">
<h4 id="determine-lengths-of-cluster-supporting-lines">4. Determine lengths of cluster-supporting lines<a class="anchor" aria-label="anchor" href="#determine-lengths-of-cluster-supporting-lines"></a>
</h4>
<p>The lengths of the cluster-supporting lines are given by the <span class="math inline">\(l()\)</span> function according to:</p>
<p><span class="math display">\[
\pmb{\ell} = l(c, l, l_\sigma)
\]</span></p>
<p>where <span class="math inline">\(\pmb{\ell}\)</span> is an <span class="math inline">\(c \times 1\)</span> vector containing the final
lengths of the cluster-supporting lines, <span class="math inline">\(c\)</span> is the number of clusters, <span class="math inline">\(l\)</span> is the average length, and <span class="math inline">\(l_\sigma\)</span> is the length dispersion.</p>
<p>The <span class="math inline">\(l()\)</span> function is an optional
parameter, allowing users to customize its behavior. By default, <span class="math inline">\(l()\)</span> is implemented by the
<code><a href="../reference/llengths.html">llengths()</a></code> function, which determines the <span class="math inline">\(\ell_i\)</span> length of each cluster-supporting
line <span class="math inline">\(i\)</span> according to:</p>
<p><span class="math display">\[
\ell_i\sim\left|\mathcal{N}(l,l_\sigma^2)\right|
\]</span></p>
<p>where <span class="math inline">\(\left|\mathcal{N}(\mu,\sigma^2)\right|\)</span>
represents the folded normal distribution with mean <span class="math inline">\(\mu\)</span> and variance <span class="math inline">\(\sigma^2\)</span>.</p>
<p>Figure 4 shows cluster-supporting line lengths obtained with
different implementations of <span class="math inline">\(l()\)</span>.</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/clugen/.github/main/images/llengths.png" alt=""><p class="caption"><strong>Figure 4</strong> - Line lengths for
different implementations of <span class="math inline">\(l()\)</span>:
a) the default, using the folded normal distribution; b) using the
Poisson distribution, with <span class="math inline">\(\lambda=l\)</span>; c) using the uniform
distribution in the interval <span class="math inline">\(\left\lbrack 0,
2l\right\rbrack\)</span>; and, d) hand-picked lengths, more specifically
<span class="math inline">\(\pmb{\ell}=\begin{bmatrix}2 &amp; 8 &amp; 16
&amp; 32\end{bmatrix}^T\)</span>. Cluster centers, as well as parameters
<span class="math inline">\(l\)</span> and <span class="math inline">\(l_\sigma\)</span>, are the same as for the example
shown in Figure 1.</p>
</div>
</div>
<div class="section level4">
<h4 id="determine-angles-between-mathbfd-and-cluster-supporting-lines">5. Determine angles between <span class="math inline">\(\mathbf{d}\)</span> and cluster-supporting
lines<a class="anchor" aria-label="anchor" href="#determine-angles-between-mathbfd-and-cluster-supporting-lines"></a>
</h4>
<p>The angles between <span class="math inline">\(\mathbf{d}\)</span>
and the cluster-supporting lines are given by the <span class="math inline">\(\theta_\Delta()\)</span> function according
to:</p>
<p><span class="math display">\[
\mathbf{\Theta_\Delta} = \theta_\Delta(c, \theta_\sigma)
\]</span></p>
<p>where <span class="math inline">\(\mathbf{\Theta_\Delta}\)</span> is
an <span class="math inline">\(c \times 1\)</span> vector containing the
final angle differences between <span class="math inline">\(\mathbf{d}\)</span> and the cluster-supporting
lines, <span class="math inline">\(c\)</span> is the number of clusters,
and <span class="math inline">\(\theta_\sigma\)</span> is the angle
dispersion.</p>
<p>The <span class="math inline">\(\theta_\Delta()\)</span> function is
an optional parameter, allowing users to customize its behavior. By
default, <span class="math inline">\(\theta_\Delta()\)</span> is
implemented by the <code><a href="../reference/angle_deltas.html">angle_deltas()</a></code> function, which
determines the <span class="math inline">\(\theta_{\Delta i}\)</span>
angle difference between <span class="math inline">\(\mathbf{d}\)</span>
and the <span class="math inline">\(i\)</span>-th cluster-supporting
line according to:</p>
<p><span class="math display">\[
\theta_{\Delta i}\sim\mathcal{WN}_{-\pi/2}^{\pi/2}(0,\theta_\sigma^2)
\]</span></p>
<p>where <span class="math inline">\(\mathcal{WN}_{-\pi/2}^{\pi/2}(\mu,\sigma^2)\)</span>
represents the wrapped normal distribution with mean <span class="math inline">\(\mu\)</span>, variance <span class="math inline">\(\sigma^2\)</span>, and support in the <span class="math inline">\(\left[-\pi/2,\pi/2\right]\)</span> interval, and
<span class="math inline">\(\theta_\sigma\)</span> is the angle
dispersion of the cluster-supporting lines.</p>
<p>Figure 5 shows the final direction of the cluster-supporting lines
for two different implementations of <span class="math inline">\(\theta_\Delta()\)</span>.</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/clugen/.github/main/images/angle_deltas.png" alt=""><p class="caption"><strong>Figure 5</strong> - Final directions of the
cluster supporting-lines for different implementations of <span class="math inline">\(\theta_\Delta()\)</span>: a) the default, where
angle differences were obtained using the wrapped normal distribution;
and, d) hand-picked angle differences, more specifically <span class="math inline">\(\mathbf{\Theta_\Delta}=\begin{bmatrix}0 &amp;
\frac{\pi}{2} &amp; 0 &amp; \frac{\pi}{2}\end{bmatrix}^T\)</span>.
Cluster centers, as well as the angle dispersion <span class="math inline">\(\theta_\sigma\)</span>, are the same as for the
example shown in Figure 1.</p>
</div>
</div>
<div class="section level4">
<h4 id="for-each-cluster-i">6. For each cluster <span class="math inline">\(i\)</span>:<a class="anchor" aria-label="anchor" href="#for-each-cluster-i"></a>
</h4>
<div class="section level5">
<h5 id="determine-direction-of-the-cluster-supporting-line">6.1. Determine direction of the cluster-supporting line<a class="anchor" aria-label="anchor" href="#determine-direction-of-the-cluster-supporting-line"></a>
</h5>
<p>In order to obtain the <span class="math inline">\(\hat{\mathbf{d}}_i\)</span> final direction of
cluster <span class="math inline">\(i\)</span> supporting line, the
following algorithm is used:</p>
<ul>
<li>
<strong>1.</strong> Find random vector <span class="math inline">\(\mathbf{r}\)</span> with each component taken from
the uniform distribution between -0.5 and 0.5.</li>
<li>
<strong>2.</strong> Normalize <span class="math inline">\(\mathbf{r}\)</span>: <span class="math display">\[
\hat{\mathbf{r}}=\cfrac{\mathbf{r}}{\left\lVert\mathbf{r}\right\rVert}
\]</span>
</li>
<li>
<strong>3.</strong> If <span class="math inline">\(|\theta_{\Delta
i}| &gt; \pi/2\)</span> or <span class="math inline">\(n=1\)</span>, set
<span class="math inline">\(\hat{\mathbf{d}}_i=\hat{\mathbf{r}}\)</span>
and terminate the algorithm.</li>
<li>
<strong>4.</strong> If <span class="math inline">\(\hat{\mathbf{r}}\)</span> is parallel to <span class="math inline">\(\hat{\mathbf{d}}\)</span> go to
<strong>1</strong>.</li>
<li>
<strong>5.</strong> Determine vector <span class="math inline">\(\mathbf{d}_\perp\)</span> orthogonal to <span class="math inline">\(\hat{\mathbf{d}}\)</span> using the first
iteration of the Gram-Schmidt process: <span class="math display">\[
\mathbf{d}_\perp=\hat{\mathbf{r}}-\cfrac{\hat{\mathbf{d}}\cdot\hat{\mathbf{r}}}{\hat{\mathbf{d}}\cdot\hat{\mathbf{d}}}\:\hat{\mathbf{d}}
\]</span>
</li>
<li>
<strong>6.</strong> Normalize <span class="math inline">\(\mathbf{d}_\perp\)</span>: <span class="math display">\[
\hat{\mathbf{d}}_\perp=\cfrac{\mathbf{d}_\perp}{\left\lVert\mathbf{d}_\perp\right\rVert}
\]</span>
</li>
<li>
<strong>7.</strong> Determine vector <span class="math inline">\(\mathbf{d}_i\)</span> at angle <span class="math inline">\(\theta_{\Delta i}\)</span> with <span class="math inline">\(\hat{\mathbf{d}}\)</span>: <span class="math display">\[
\mathbf{d}_i=\hat{\mathbf{d}}+\tan(\theta_{\Delta
i})\hat{\mathbf{d}}_\perp
\]</span>
</li>
<li>
<strong>8.</strong> Normalize <span class="math inline">\(\mathbf{d}_i\)</span>: <span class="math display">\[
\hat{\mathbf{d}}_i=\cfrac{\mathbf{d}_i}{\left\lVert\mathbf{d}_i\right\rVert}
\]</span>
</li>
</ul>
</div>
<div class="section level5">
<h5 id="determine-distance-of-point-projections-from-the-center-of-the-cluster-supporting-line">6.2. Determine distance of point projections from the center of the
cluster-supporting line<a class="anchor" aria-label="anchor" href="#determine-distance-of-point-projections-from-the-center-of-the-cluster-supporting-line"></a>
</h5>
<p>The distance of point projections from the center of the
cluster-supporting line is given by the <span class="math inline">\(p_\text{proj}()\)</span> function according
to:</p>
<p><span class="math display">\[
\mathbf{w}_i = p_\text{proj}(\ell_i, p_i)
\]</span></p>
<p>where <span class="math inline">\(\mathbf{w}_i\)</span> is an <span class="math inline">\(p_i \times 1\)</span> vector containing the
distance of each point projection to the center of the line, while <span class="math inline">\(\ell_i\)</span> and <span class="math inline">\(p_i\)</span> are the line length and number of
points in cluster <span class="math inline">\(i\)</span>,
respectively.</p>
<p>The <span class="math inline">\(p_\text{proj}()\)</span> function is
an optional parameter, allowing users to customize its behavior.
<code>clugenr</code> provides two concrete implementations out of the
box, specified by passing <code>"norm"</code> or <code>"unif"</code> to
<code><a href="../reference/clugen.html">clugen()</a></code>’s <code>proj_dist_fn</code> parameter. These work
as follows:</p>
<ul>
<li>
<code>"norm"</code> (default) - Each element of <span class="math inline">\(\mathbf{w}_i\)</span> is derived from <span class="math inline">\(\mathcal{N}(0, (\frac{\ell_i}{6})^2)\)</span>,
i.e., from the normal distribution, centered on the cluster-supporting
line center (<span class="math inline">\(\mu=0\)</span>) and with a
standard deviation of <span class="math inline">\(\sigma=\frac{\ell_i}{6}\)</span>, such that the
length of the line segment encompasses <span class="math inline">\(\approx\)</span> 99.73% of the generated
projections. Consequently, some projections may be placed outside the
line’s end points.</li>
<li>
<code>"unif"</code> - Each element of <span class="math inline">\(\mathbf{w}_i\)</span> is derived from <span class="math inline">\(\mathcal{U}(-\frac{\ell_i}{2},
\frac{\ell_i}{2})\)</span>, i.e., from the continuous uniform
distribution in the interval <span class="math inline">\(\left[-\frac{\ell_i}{2},
\frac{\ell_i}{2}\right[\)</span>. Thus, projections will be uniformly
dispersed along the cluster-supporting line.</li>
</ul>
<p>The impact of various implementations of <span class="math inline">\(p_\text{proj}()\)</span> is demonstrated in Figure
6. Figures 6a and 6b show the clusters generated with the
<code>"norm"</code> and <code>"unif"</code> options, respectively, while
Figures 6c and 6d highlight custom user functions implementing the
Laplace and Rayleigh distributions, respectively. All parameters are set
as in Figure 1, except for <span class="math inline">\(p_\text{proj}()\)</span> in the case of Figures
6b-6d, and <span class="math inline">\(p\)</span>, which is set to
5000.</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/clugen/.github/main/images/proj_dist_fn.png" alt=""><p class="caption"><strong>Figure 6</strong> - Clusters generated for
various implementations of <span class="math inline">\(p_\text{proj}()\)</span>: a) the default, where
line center distances are drawn for the normal distribution, specified
using the in-built <code>"norm"</code> option; b) in which center
distances are derived from the uniform distribution, via the in-built
<code>"unif"</code> option; c) where line center distances are obtained
from a custom user function implementing the Laplace distribution; and,
d) in which a custom user function returns center distances drawn from
the Rayleigh distribution. All parameters are set as in Figure 1, except
for <span class="math inline">\(p_\text{proj}()\)</span> in the case of
Figures 6b-6d, and <span class="math inline">\(p\)</span>, which is set
to 5000.</p>
</div>
</div>
<div class="section level5">
<h5 id="determine-coordinates-of-point-projections-on-the-cluster-supporting-line">6.3. Determine coordinates of point projections on the
cluster-supporting line<a class="anchor" aria-label="anchor" href="#determine-coordinates-of-point-projections-on-the-cluster-supporting-line"></a>
</h5>
<p>This is a deterministic step performed by the
<code><a href="../reference/points_on_line.html">points_on_line()</a></code> function using the vector formulation of
the line equation, as follows:</p>
<p><span class="math display">\[
\mathbf{P}_i^\text{proj}=\mathbf{1}\,\mathbf{c}_i^T +
\mathbf{w}_i\hat{\mathbf{d}}_i^T
\]</span></p>
<p>where <span class="math inline">\(\mathbf{P}_i^\text{proj}\)</span>
is the <span class="math inline">\(p_i \times n\)</span> matrix of point
projection coordinates on the line, <span class="math inline">\(\mathbf{1}\)</span> is an <span class="math inline">\(p_i \times 1\)</span> vector with all entries
equal to 1, <span class="math inline">\(\mathbf{c}_i\)</span> are the
coordinates of the line center (<span class="math inline">\(n \times
1\)</span> vector), <span class="math inline">\(\mathbf{w}_i\)</span> is
the distance of each point projection to the center of the line (<span class="math inline">\(p_i \times 1\)</span> vector obtained in the
previous step), and <span class="math inline">\(\hat{\mathbf{d}}_i\)</span> is the direction of
the cluster-supporting line for cluster <span class="math inline">\(i\)</span>.</p>
</div>
<div class="section level5">
<h5 id="determine-points-from-their-projections-on-the-cluster-supporting-line">6.4. Determine points from their projections on the
cluster-supporting line<a class="anchor" aria-label="anchor" href="#determine-points-from-their-projections-on-the-cluster-supporting-line"></a>
</h5>
<p>The final cluster points, obtained from their projections on the
cluster-supporting line, are given by the <span class="math inline">\(p_\text{final}()\)</span> function according
to:</p>
<p><span class="math display">\[
\mathbf{P}_i^\text{final} = p_\text{final}(\mathbf{P}_i^\text{proj},
f_\sigma, \ell_i, \hat{\mathbf{d}}_i, \mathbf{c}_i)
\]</span></p>
<p>where <span class="math inline">\(\mathbf{P}_i^\text{final}\)</span>
is a <span class="math inline">\(p_i \times n\)</span> matrix containing
the coordinates of the generated points, <span class="math inline">\(\mathbf{P}_i^\text{proj}\)</span> is the <span class="math inline">\(p_i \times n\)</span> matrix of projection
coordinates (determined in the previous step), and <span class="math inline">\(f_\sigma\)</span> is the lateral dispersion
parameter. In turn, <span class="math inline">\(\ell_i\)</span>, <span class="math inline">\(\hat{\mathbf{d}}_i\)</span> and <span class="math inline">\(\mathbf{c}_i\)</span> are the length, direction
and center of the cluster-supporting line.</p>
<p>The <span class="math inline">\(p_\text{final}()\)</span> function is
an optional parameter, allowing users to customize its behavior.
<code>clugenr</code> provides two concrete implementations out of the
box, specified by passing <code>"n-1"</code> or <code>"n"</code> to
<code><a href="../reference/clugen.html">clugen()</a></code>’s <code>point_dist_fn</code> parameter. These work
as follows:</p>
<ul>
<li>
<code>"n-1"</code> (default) - Points are placed on a hyperplane
orthogonal to the cluster-supporting line and intersecting the point’s
projection. This is done by obtaining <span class="math inline">\(p_i\)</span> random unit vectors orthogonal to
<span class="math inline">\(\hat{\mathbf{d}}_i\)</span>, and determining
their magnitude using the normal distribution (<span class="math inline">\(\mu=0\)</span>, <span class="math inline">\(\sigma=f_\sigma\)</span>). These vectors are then
added to the respective projections on the cluster-supporting line,
yielding the final cluster points. This behavior is implemented in the
<code><a href="../reference/clupoints_n_1.html">clupoints_n_1()</a></code> function.</li>
<li>
<code>"n"</code> - Points are placed around their respective
projections. This is done by obtaining <span class="math inline">\(p_i\)</span> random unit vectors, and determining
their magnitude using the normal distribution (<span class="math inline">\(\mu=0\)</span>, <span class="math inline">\(\sigma=f_\sigma\)</span>). These vectors are then
added to the respective projections on the cluster-supporting line,
yielding the final cluster points. This behavior is implemented in the
<code><a href="../reference/clupoints_n.html">clupoints_n()</a></code> function.</li>
</ul>
<p>Figure 7 highlights the differences between these two approaches in
2D, where a hyperplane is simply a line.</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/clugen/.github/main/images/point_dist_ex.png" alt=""><p class="caption"><strong>Figure 7</strong> - Example of how the final
cluster points are obtained in 2D when using the built-in
implementations for <span class="math inline">\(p_\text{final}()\)</span>.</p>
</div>
<p>In general, points can be placed using a <code>"n-1"</code> or
<code>"n"</code> strategy using any distribution. Figure 8 displays
several examples for various implementations of <span class="math inline">\(p_\text{final}()\)</span>, either based on
<code>"n-1"</code> or <code>"n"</code> strategy, using different
distributions. Figures 8a and 8b show the built-in <code>"n-1"</code>
and <code>"n"</code> strategies making use of the normal distribution.
Figures 8c-8f highlight some possibilities with custom user functions.
Figure 8c shows the effect of using the exponential distribution in a
<code>"n-1"</code> strategy, while Figure 8d displays the result of
using a bimodal distribution with the same strategy. A more complex
distribution, producing “hollow” clusters with a <code>"n"</code>
strategy, is employed in Figures 8e and 8f, with the latter also having
the <span class="math inline">\(p_\text{proj}()\)</span> function set to
<code>"unif"</code>. The remaining parameters (for all subfigures) are
set as in Figure 1, except for <span class="math inline">\(p\)</span>,
which is set to 5000.</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/clugen/.github/main/images/point_dist_fn.png" alt=""><p class="caption"><strong>Figure 8</strong> - Examples of various
implementations of <span class="math inline">\(p_\text{final}()\)</span>. Figures a and b shown
the effect of the built-in implementations, while Figures c-f display
results obtained using custom user functions.</p>
</div>
</div>
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
